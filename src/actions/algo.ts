// fair-node.ts

import fs from 'fs';
import Graph from 'graphology';
import { dijkstra } from 'graphology-shortest-path';

/**
 * Computes the total weight (travel time) along the given path.
 * Assumes edge weights are stored under the provided attribute name.
 */
function calculatePathLength(graph: Graph, path: string[], weightAttr: string): number {
  let total = 0;
  for (let i = 1; i < path.length; i++) {
    // Get the edge key between two consecutive nodes.
    const edgeKey = graph.edge(path[i - 1], path[i]);
    if (edgeKey === undefined) {
      throw new Error(`Missing edge between ${path[i - 1]} and ${path[i]}`);
    }
    total += graph.getEdgeAttribute(edgeKey, weightAttr);
  }
  return total;
}

/**
 * Loads a graph from a node‑link JSON file.
 * The file should be in the same format as generated by networkX's node_link_data.
 */
export function loadGraph(filename: string): Graph {
  const raw = fs.readFileSync(filename, { encoding: 'utf-8' });
  const data = JSON.parse(raw);
  // Graph.from is available in recent versions of Graphology.
  return Graph.from(data);
}

/**
 * Returns an array of station IDs (graph nodes) with a matching 'name' attribute.
 */
export function findStationsByName(graph: Graph, stationName: string): string[] {
  return graph.nodes().filter(node => graph.getNodeAttribute(node, 'name') === stationName);
}

/**
 * Computes the "fair" node: the node that minimizes the worst-case (maximum) travel time
 * from all given source stations.
 *
 * @param graph The graph instance.
 * @param sourceIds Array of source station IDs.
 * @returns A tuple [fairNode, worstTime] where fairNode is the optimal node and worstTime its maximum travel time.
 */
export function computeFairNode(graph: Graph, sourceIds: string[]): [string | null, number] {
  const distances: Record<string, Record<string, number>> = {};

  // For each source, compute the shortest path tree.
  for (const src of sourceIds) {
    const paths = dijkstra.singleSource(graph, src, 'weight');
    distances[src] = {};
    for (const node in paths) {
      try {
        distances[src][node] = calculatePathLength(graph, paths[node], 'weight');
      } catch (error) {
        // Skip nodes if path calculation fails.
      }
    }
  }

  let bestNode: string | null = null;
  let bestWorstTime = Infinity;

  // Consider every node as a candidate for the fair node.
  for (const node of graph.nodes()) {
    let maxTime = 0;
    let reachable = true;
    for (const src of sourceIds) {
      if (distances[src][node] !== undefined) {
        maxTime = Math.max(maxTime, distances[src][node]);
      } else {
        reachable = false;
        break;
      }
    }
    if (reachable && maxTime < bestWorstTime) {
      bestWorstTime = maxTime;
      bestNode = node;
    }
  }

  return [bestNode, bestWorstTime];
}

/**
 * Resolves a list of station names (taking the first match for each) and computes the fair node.
 *
 * @param graph The graph instance.
 * @param stationNames Array of station names.
 * @returns A tuple [fairNode, worstTime] or [null, null] if none of the stations were found.
 */
export function computeFairForStations(graph: Graph, stationNames: string[]): [string | null, number | null] {
  const sourceIds: string[] = [];
  for (const name of stationNames) {
    const ids = findStationsByName(graph, name);
    if (ids.length > 0) {
      sourceIds.push(ids[0]);
    } else {
      console.warn(`Station '${name}' not found.`);
    }
  }
  if (sourceIds.length === 0) return [null, null];
  return computeFairNode(graph, sourceIds);
}

/**
 * Displays travel times and routes from a given center node to each station by name.
 *
 * @param graph The graph instance.
 * @param centerNode The center node (as a station ID).
 * @param stationNames Array of station names.
 */
export function displayTravelTimesFromCenter(graph: Graph, centerNode: string, stationNames: string[]): void {
  const paths = dijkstra.singleSource(graph, centerNode, 'weight');

  for (const name of stationNames) {
    const ids = findStationsByName(graph, name);
    if (ids.length === 0) {
      console.log(`Station '${name}' not found.`);
      continue;
    }
    const target = ids[0];
    if (!(target in paths)) {
      console.log(`No path from center to '${name}'.`);
      continue;
    }
    const travelTime = calculatePathLength(graph, paths[target], 'weight');
    const route = paths[target]
      .map(n => graph.getNodeAttribute(n, 'name') || n)
      .join(' → ');
    console.log(`From center to '${name}': ${travelTime.toFixed(1)} minutes`);
    console.log(`  Route: ${route}\n`);
  }
}
